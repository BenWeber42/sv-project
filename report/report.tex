% This is based on "sig-alternate.tex" V1.9 April 2009
% This file should be compiled with V2.4 of "sig-alternate.cls" April 2009
%
\documentclass{report}

\usepackage[english]{babel}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{subfigure}
\usepackage{enumitem}
\usepackage{url}

\usepackage{color}
\definecolor{orange}{rgb}{1,0.5,0}
\definecolor{lightgray}{rgb}{.9,.9,.9}
\definecolor{java_keyword}{rgb}{0.37, 0.08, 0.25}
\definecolor{java_string}{rgb}{0.06, 0.10, 0.98}
\definecolor{java_comment}{rgb}{0.12, 0.38, 0.18}
\definecolor{java_doc}{rgb}{0.25,0.35,0.75}

% code listings

\usepackage{listings}
\lstloadlanguages{Java}
\lstset{
	language=Java,
	basicstyle=\scriptsize\ttfamily,
	backgroundcolor=\color{lightgray},
	keywordstyle=\color{java_keyword}\bfseries,
	stringstyle=\color{java_string},
	commentstyle=\color{java_comment},
	morecomment=[s][\color{java_doc}]{/**}{*/},
	tabsize=2,
	showtabs=false,
	extendedchars=true,
	showstringspaces=false,
	showspaces=false,
	breaklines=true,
	numbers=left,
	numberstyle=\tiny,
	numbersep=6pt,
	xleftmargin=3pt,
	xrightmargin=3pt,
	framexleftmargin=3pt,
	framexrightmargin=3pt,
	captionpos=b
}

% Disable single lines at the start of a paragraph (Schusterjungen)

\clubpenalty = 10000

% Disable single lines at the end of a paragraph (Hurenkinder)

\widowpenalty = 10000
\displaywidowpenalty = 10000
 
% allows for colored, easy-to-find todos

\newcommand{\todo}[1]{\textsf{\textbf{\textcolor{orange}{[[#1]]}}}}

% consistent references: use these instead of \label and \ref

\newcommand{\lsec}[1]{\label{sec:#1}}
\newcommand{\lssec}[1]{\label{ssec:#1}}
\newcommand{\lfig}[1]{\label{fig:#1}}
\newcommand{\ltab}[1]{\label{tab:#1}}
\newcommand{\rsec}[1]{Section~\ref{sec:#1}}
\newcommand{\rssec}[1]{Section~\ref{ssec:#1}}
\newcommand{\rfig}[1]{Figure~\ref{fig:#1}}
\newcommand{\rtab}[1]{Table~\ref{tab:#1}}
\newcommand{\rlst}[1]{Listing~\ref{#1}}

% General information

\title{Software Verification -- Course Project Report}

% Use the \alignauthor commands to handle the names
% and affiliations for an 'aesthetic maximum' of six authors.

\numberofauthors{2}
\author{
% You can go ahead and credit any number of authors here,
% e.g. one 'row of three' or two rows (consisting of one row of three
% and a second row of one, two or three).
%
% The command \alignauthor (no curly braces needed) should
% precede each author name, affiliation/snail-mail address and
% e-mail address. Additionally, tag each line of
% affiliation/address with \affaddr, and tag the
% e-mail address with \email.
%
% 1st. author
\alignauthor Benjamin Weber\\
	\affaddr{ETH ID 11-933-017}\\
	\email{benweber@student.ethz.ch}
% 2nd. author
\alignauthor Marcel Mohler\\
	\affaddr{ETH ID 09-922-998}\\
	\email{mohlerm@student.ethz.ch}
}


\begin{document}

\maketitle

\begin{abstract}
\textbf{By using \textit{Software Verification} a programmer wants to achieve guarantees in terms of previously defined properties.\\
In theory however, it is undecidable whether a given piece of code conforms to its specification, hence researchers have proposed and developed various semi-automatic methods.\\
One approach called \textit{Auto-Active Verification} tries to automate as much as possible, while the programmer provides guidance indirectly through program-level annotations\cite{autoactivelecture}.
We use the verifier AutoProof\cite{autoproof} to verify different algorithms on the program level. \\Furthermore, we present an implementation of quick sort\cite{quicksort} and bucket sort\cite{bucketsort} in the \textit{intermediate verification language} (IVL) boogie\cite{boogie}. We provide the needed annotations to formally prove correctness of the implementation with respect to the specification.
}
\end{abstract}

\section{Introduction}
\label{s:introduction}
As part of the \textbf{software verification} course offered by \textbf{ETH Zurich},
we had to complete a project involving software verification on the program
level with AutoProof as well as on the intermediate level through Boogie.\\
In section \ref{s:autoproof} we discuss software verification using AutoProof.
We continue to discuss the Boogie part in section \ref{s:boogie} and compare
the two in section \ref{s:comparison}. Finally, we present our conclusion in
section \ref{s:conclusion}.

\section{Autoproof verficiation}
\label{s:autoproof}

Many features already had a specification attached. Thus, it was sufficient to
make the autoproof tool accept the implementation using hints such as assertions
or invariants.
\\
\\
The \textbf{wipe} feature could successfully be verified once we specified in the loop
invariant that the post-condition was gradually established. This strategy
turned out to be useful for the whole project.
\\
\\
The \textbf{mod\_three} feature could be verified similarly. We just had to
specify what didn't get modified additionally.
\\
\\
We needed to specify more to verify the \textbf{swapper} feature. To establish
the pre-conditions of \textbf{swap} two invariants regarding \textbf{x} and
\textbf{y} were necessary. Once those pre-conditions could be established, the
previous strategy was sufficient to verify the whole feature.
\\
\\
The \textbf{search} feature is special because we also had to specify the 
post-conditions ourselves. No tool can verify whether the post-conditions truely
capture the full extent of what the programmer means to achieve.\\
We believe the correct meaning of the \textbf{search} feature is that it does
not modify the list to be search and that it returns \textbf{true} only iff
the given integer is in that list.\\
The \textbf{has} feature of the ghost-feature \textbf{sequence} was very useful
to express the intuition above in AutoProof.\\
To verify the feature it was sufficient to explicitelly state the implications
of \textbf{Result} for both cases \textbf{true} and \textbf{false}.
\\
\\
Verifying the \textbf{prod\_sum} feature was rather trivial by specifying that
the post-condition was gradually established.
\\
\\
In contrast the \textbf{paly} feature was more complicated. First the pre-conditions
had to be established by adding simple invariants about \textbf{x} and \textbf{y}.
Then we used the strategy to show AutoProof that the post-condition is gradually
established by the loop.\\
But that still wasn't enough. Thus we had to specify explicitelly the counter-example
when \textbf{Result} became \textbf{false}.\\
Again, we had to be careful that the post-condition fully captured the meaning
of the \textbf{paly} feature. We believe we achieved this by establishing the
correctness through the post-condition involving the result and by establishing
that the parameter does not get modified.

\section{Boogie}
\label{s:boogie}
Boogie is an intermediate verification language (IVL), intended as a layer on which to build program verifiers for other languages\cite{boogiegithub}.\\
It is also the name of a tool that accepts Boogie language as input and then generates verification conditions that are passed to an SMT solver like Z3\cite{z3}.\\
Initially, it has been developed by Microsoft Research but is also open to other contributors on Github.

\subsection{Boogie implementation}

Using Boogie to implement the given algorithms didn't pose a challenge.
Eventhough Boogie's simplicity, both algorithms could be expressed well.
While Boogie has powerful means to abstract complicated concepts, we only
needed some very simple language structures of Boogie to express an array to be
sorted.\\
One particular interesting design choice was to implement the partition step
of the quicksort algorithms in such a way that it could be reused by the bucketsort
algorithm.\\
This simplified the implementation due to the additional code reuse and didn't
make the verification or speficiation more complicated.

\todo{Implement the sorting algorithm described in
Section 3.2. Discuss your design choices, and how you modelled the algorithm using the
primitives of Boogie}

\subsection{Boogie specification}
In principle, our sort implementations have to fulfill two properties.\\
Most importantly, the resulting array has to be sorted. This is pretty trivial and we used
a simple boolean function to express this specification.
\begin{lstlisting}
function sorted(a: [int]int, lo, hi: int): bool
{
  hi - lo >= 1
  &&
  (forall i, j: int :: lo <= i 
  && i <= j 
  && j <= hi ==> a[i] <= a[j]
  )
}
\end{lstlisting}
Furthermore we need to make sure, that the sorted array is actually a valid
permutation of the input array. Modelling this property turned out to be the most difficult part
of this project.\\
We tried a few different solutions which we will describe in more detail.
A very early idea was to define the properties with axioms.\\ 
Using axioms to provide boogie with additional theoretical constraints is a very simple yet dangerous approach. Because boogie will not prove the validity of these axioms, the correctness of a validation using these axioms relies on the correctness of the axioms.\\
So if we design the axioms poorly we might end up proving incorrect statements (unsound).\todo{add example}.\\
Other/auto proof/ counts. \todo{det chasch du vellecht besser oeppis zum verlauf saege + biispiel code}.\\
Because of the mentioned pitfalls of the previous attempts we decided to model the property by keeping an additional permutation array, that stores the modification of the input array to the final, sorted array. This allows us to easily verify if the current array is a permutation of the initial one at the cost of storing two more arrays of the same length N. Further details can be found in Section \ref{s:boogie_verification}.\todo{wieso hemmer eigentlech die init() methode nuemm?}
\\\\
In general, expressing the specifications on Boogie was interesting due to two different aspects.
\\
\\
Firstly, there was the challenge to fully capture the meaning of an algorithm
through the specification.\\
Boogie was very helpful there with its rather powerful expression language which
contains both the universal and existential quantifiers.
However, one also had to be careful to express formulas such that Boogie could
handle them well. Otherwise, more annotations are necessary which is less desirable.
\\
\\
Secondly, it was often surprising to see what a complete specification was for a procedure.
An incomplete specification often leads to the failure of the verification.
Thus we often came across incomplete specifications.\\
We learned that in addition to specifying what did get changed we also had to
specify what didn't get changed. A complicated example of this can be found in
the \textbf{quicksort} and \textbf{partition} procedures.\\
Both of these procedures preserve the property that if some values were previously
bigger-equal than all values in a given range, those values will still be bigger-equal
after the procedure call.\\
While this is trivially obvious because both procedures only permute an array,
it's not trivially obvious that this property is necessary to verify the
\textbf{quicksort} and \textbf{bucketsort} implementations.

\todo{Specify the complete behaviour of the sorting algorithm
using the specification primitives of Boogie. Discuss your specification choices, in
particular, how you modelled the “permutation” property for the resulting array.
Describe any difficulties and how you overcame them. Contrast the specification
language of Boogie with the specification language of AutoProof.}

\subsection{Boogie verification}
\label{s:boogie_verification}
We were able to verify the correctness of our implementation based on the sorted and permutation properties.\\
We will describe a few challenges and issues we encountered during the verification process.
\\\\
One of the main issues we had was termination. In boogie we are only able to prove partial correctness. In contrast to total correctness, which means that the program behaves correctly with respect to its specification, partial correctness is a weaker notion which only requires a correct result if the program terminates.\\
Applied to our scenario this meant that if we do not carefully design our algorithms such that they always terminate, we might end up with postconditions that evaluate to trivially true because they can never be reached.\\
See this small example, which verifies correctly in boogie even though \texttt{1 == 0} is clearly a false statement.
\begin{lstlisting}
procedure F(n: int) returns (r: int)
  ensures 1 == 0;
{
  while(true) {
    r := n;
  }
  r := 0;
}
\end{lstlisting}
If we change the \texttt{while(true)} in line 4 to \texttt{while(false)} boogie correctly reports that the postcondition might not hold.
\\\\
We also found the fact that we can not define pre conditions for functions limiting. Taking the example of \texttt{sorted()}, we would have liked to require an $N \leq 2$ because we handle the case of the empty and list of length 1 separately. Due to the way we defined \texttt{sorted()} it currently returns false for these special cases which is not ideal as we have false positives for \texttt{!sorted} (exactly these two cases, \texttt{N==0} and \texttt{N==1}). A precondition would allow us to define a property in a similar fashion as zero-division \texttt{x/0} is defined to be not possible.\todo{toent alles nonig so rund ond vellecht soett me die genaue uswirkige vo uesem approach no aschniide}.
\\\\
\todo{Ond au de unterschied zwösche "requires perm\_of(...); ensures perm\_of(...);" vs "ensures perm\_of(... old  ...) ==> perm\_of(...);"
Well requires söttet contracts si, wo de algorithmus brucht, aber quicksort etc funktioniert au ohni perm\_of ond dorch die 2. variante werd das requires wie freiwillig ond mer chönt trotzdem spezifiziere/verifiziere, dass dpermutation erhalte blibt.}
\\\\
\todo{requires send guet, well mer chan secherstelle, dass de call korrekt esch, aber glichzitig hämmer jetzt mega vell ad hoc code "if (lo <= hi) \{ call quicksort(lo, hi); \}", anstatt, dass mer de fall im quicksort abfangt ond ignoriert. Aber dene verlürt mer sicherheit.}
\\\\
\todo{loop invariants vs assertions, dass halt loop invariante wie pre-/post-conditions send (stoht vl au em language manual so ähnlech)}
\\\\
\todo{Verify your Boogie program using Boogie. Report any
significant problems you encountered; for example, which procedures you could verify
and which ones you could not. Describe if there were any aspects of the implementation
or of the specification you had to change to make them easier to verify. Describe whichparts of the specification you could not verify, and what the limitations were that
prevented you from doing it. Explain how you achieved modular verification.}

\section{Comparison Autoproof \& Boogie}
\label{s:comparison}
\todo{Particular effort should be made to contrast your experiences doing verification at the
program level (AutoProof) and intermediate verification language level (Boogie).}

\section{Conclusion}
\label{s:conclusion}
We found it very exciting to apply the concepts of Auto-Active Verification to a larger example. In the lectures we have always seen these concepts being applied to small and simple functions, where verification was rather trivial. And while quick sort and bucket sort are still only a few dozen lines of code, the verification code adds at least the same amount of lines on top of the implementation.
We realized that it can be tricky to design a sound system...
\todo{finish}



% The following two commands are all you need in the
% initial runs of your .tex file to
% produce the bibliography for the citations in your paper.
\bibliographystyle{abbrv}
\bibliography{report}  % sigproc.bib is the name of the Bibliography in this case
% You must have a proper ".bib" file

%\balancecolumns % GM June 2007

\end{document}
